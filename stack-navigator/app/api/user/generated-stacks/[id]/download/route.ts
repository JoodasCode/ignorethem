import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase-server'
import JSZip from 'jszip'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const supabase = createServerSupabaseClient()
    
    // Get the current user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      )
    }

    const { id: stackId } = await params

    // Fetch the stack
    const { data: stack, error } = await supabase
      .from('user_generated_stacks')
      .select('*')
      .eq('id', stackId)
      .eq('user_id', user.id)
      .single()

    if (error || !stack) {
      return NextResponse.json(
        { error: 'Stack not found' },
        { status: 404 }
      )
    }

    // Increment download count
    await supabase
      .from('user_generated_stacks')
      .update({ download_count: (stack.download_count || 0) + 1 })
      .eq('id', stackId)

    // Create ZIP file
    const zip = new JSZip()
    
    // Add a README with stack information
    const readme = `# ${stack.stack_name}

${stack.stack_description || 'Generated tech stack'}

## Technologies Used
${stack.technologies.map((tech: string) => `- ${tech}`).join('\n')}

## Generated on
${new Date(stack.created_at).toLocaleDateString()}

---
Generated by Stack Navigator
`
    
    zip.file('README.md', readme)

    // Add generated files if they exist
    if (stack.generated_files && typeof stack.generated_files === 'object') {
      const addFilesToZip = (files: any, basePath = '') => {
        for (const [filename, content] of Object.entries(files)) {
          const fullPath = basePath ? `${basePath}/${filename}` : filename
          
          if (typeof content === 'string') {
            // It's a file
            zip.file(fullPath, content)
          } else if (typeof content === 'object' && content !== null) {
            // It's a directory
            addFilesToZip(content, fullPath)
          }
        }
      }
      
      addFilesToZip(stack.generated_files)
    } else {
      // Add a placeholder file if no generated files
      zip.file('placeholder.txt', 'This stack was generated but no files were saved.')
    }

    // Generate ZIP buffer
    const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' })
    
    // Create filename
    const filename = `${stack.stack_name.replace(/[^a-zA-Z0-9]/g, '_')}_stack.zip`

    // Return ZIP file
    return new NextResponse(new Uint8Array(zipBuffer), {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': zipBuffer.length.toString(),
      },
    })
  } catch (error) {
    console.error('Error in GET /api/user/generated-stacks/[id]/download:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}